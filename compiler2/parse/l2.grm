(* LOLCODE Compiler *)

structure A = Ast

(* for simplicity, we only mark expressions, not statements *)

(* mark e with region (left, right) in source file *)
fun mark (e, (left, right)) = A.Marked (Mark.mark' (e, ParseState.ext (left, right)))
fun marks (s, (left, right)) = A.Markeds (Mark.mark' (s, ParseState.ext (left, right)))

%%
%header (functor L2LrValsFn (structure Token : TOKEN))

%term
   EOF
 | HAI
 | KTHXBYE
 | FOUNDYR
 | IHAZA
 | ITZ
 | HOW
 | DUZ
 | I
 | MAIN
 | IF
 | U
 | SAY
 | SO
 | O
 | RLYY
 | YA
 | RLY
 | NO
 | WAI
 | OIC
 | SAEM
 | DIFFRINT
 | IM
 | IN
 | YR
 | OUTTA
 | TIL
 | WILE
 | GTFO
 | UPPIN
 | NERFIN
 | R
 | AN
 | INTCONST of Word32.word
 | WIN
 | FAIL
 | IDENT of Symbol.symbol
 | SUMOF | DIFFOF | PRODUKTOF | QUOSHUNTOF | MODOF
 | BIGGR | SMALLR
 | EITHER | BOTH
 | OF
 | NEG | NOT
 | UNARY

%nonterm
   program  of A.stmt list
 | stmts    of A.stmt list
 | stmt     of A.stmt
 | decl     of A.stmt
 | declas   of A.stmt
 | simp     of A.stmt
 | control  of A.stmt
 | lvalue   of A.ident
 | exp      of A.exp

%verbose       (* print summary of errors *)
%pos int       (* positions *)
%start program (* what is the top-most non-terminal expected to be ? *)
%eop EOF       (* which terminal ends parsing? *)
%noshift EOF   (* we should never shift an EOF *)

%name L2

(* The precedence grows down! *)
%left SUMOF DIFFOF PRODUKTOF QUOSHUNTOF MODOF NEG
%right NO
%right UNARY

%%
program    : HAI HOW DUZ I MAIN stmts IF U SAY SO KTHXBYE (stmts)

stmts      :                       ([])
           | stmt stmts            (stmt :: stmts)

stmt       : control               (control)
           | simp                  (marks (simp, (simpleft, simpright)))

simp       : IHAZA IDENT           (marks (A.Declare (IDENT, NONE), (IHAZAleft, IDENTright)))
           | IHAZA IDENT ITZ exp   (marks (A.Declare (IDENT, SOME exp), (IHAZAleft, expright)))
           | IDENT R exp           (marks (A.Assign (IDENT, exp), (IDENTleft, expright)))

control    : exp O RLYY YA RLY stmts NO WAI stmts OIC %prec NO
                                   (A.IfThenElse(exp, A.Seq(stmts1), A.Seq(stmts2)))
           | exp O RLYY YA RLY stmts OIC %prec NO
                                   (A.IfThenElse(exp, A.Seq(stmts1), A.Seq([A.Nop])))
           | FOUNDYR exp           (marks ((A.Return exp), (FOUNDYRleft, expright)))

exp        : INTCONST              (mark (A.ConstExp(A.IntConst(INTCONST)),(INTCONSTleft,INTCONSTright)))
           | WIN                   (mark (A.ConstExp(A.TRUE),(WINleft,WINright)))
           | FAIL                  (mark (A.ConstExp(A.FALSE),(FAILleft,FAILright)))
           | IDENT                 (mark (A.Var(IDENT), (IDENTleft,IDENTright)))
           | SUMOF exp AN exp      (mark (A.BinopExp (A.PLUS,exp1,exp2), (SUMOFleft,exp2right)))
           | DIFFOF exp AN exp     (mark (A.BinopExp (A.MINUS,exp1,exp2), (DIFFOFleft,exp2right)))
           | PRODUKTOF exp AN exp  (mark (A.BinopExp (A.TIMES,exp1,exp2), (exp1left,exp2right)))
           | QUOSHUNTOF exp AN exp (mark (A.BinopExp (A.DIVIDEDBY,exp1,exp2), (QUOSHUNTOFleft,exp2right)))
           | MODOF exp AN exp      (mark (A.BinopExp (A.MODULO,exp1,exp2), (MODOFleft,exp2right)))
           | NEG exp               (mark (A.UnopExp (A.NEGATIVE,exp), (NEGleft,expright)))
           | BOTH OF exp AN exp    (mark (A.BinopExp (A.AND,exp1,exp2), (BOTHleft, exp2right)))
           | EITHER OF exp AN exp  (mark (A.BinopExp (A.OR,exp1,exp2), (EITHERleft, exp2right))) 
           | NOT exp %prec UNARY   (mark (A.UnopExp (A.NOT,exp), (NOTleft, expright)))
           | BIGGR OF exp AN exp   (mark (A.BinopExp (A.GT,exp1,exp2), (BIGGRleft, expright)))
           | SMALLR OF exp AN exp  (mark (A.BinopExp (A.LT,exp1,exp2), (SMALLRleft, expright)))
           | BOTH SAEM exp AN exp  (mark (A.BinopExp (A.EQ,exp1,exp2), (BOTHleft, exp2right)))
           | DIFFRINT exp AN exp   (mark (A.BinopExp (A.NEQ,exp1,exp2), (DIFFRINTleft, exp2right)))
